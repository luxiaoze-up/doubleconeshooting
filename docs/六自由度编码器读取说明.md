# 六自由度编码器读取说明

## 编码器读取实现

### 修改前的问题

之前的 `update_axis_positions()` 函数**没有真正从编码器硬件读取值**：

```cpp
void SixDofDevice::update_axis_positions() {
    // 不再从编码器读取，直接使用存储的 current_leg_lengths_
    axis_pos_ = current_leg_lengths_;
}
```

这意味着：
- `axis_pos_` 只是内部计算的值，不是真实硬件反馈
- 无法检测实际位置偏差
- 编码器硬件形同虚设

### 修改后的实现

现在 `update_axis_positions()` 会**真正从编码器设备读取实时位置**：

```cpp
void SixDofDevice::update_axis_positions() {
    // 从编码器设备读取真实位置
    if (sim_mode_) {
        // 模拟模式：使用存储的 current_leg_lengths_
        axis_pos_ = current_leg_lengths_;
        return;
    }
    
    auto encoder = get_encoder_proxy();
    if (!encoder) {
        // 编码器不可用，使用存储的值
        axis_pos_ = current_leg_lengths_;
        return;
    }
    
    try {
        // 从编码器设备读取所有6个轴的位置
        for (int axis = 0; axis < NUM_AXES; ++axis) {
            if (axis < static_cast<int>(encoder_channels_.size())) {
                short encoder_channel = encoder_channels_[axis];
                try {
                    // 调用编码器设备的readEncoder命令，传入通道号
                    Tango::DeviceData data_in;
                    data_in << encoder_channel;
                    Tango::DeviceData data_out = encoder->command_inout("readEncoder", data_in);
                    double encoder_pos;
                    data_out >> encoder_pos;
                    
                    // 更新轴位置
                    axis_pos_[axis] = encoder_pos;
                    current_leg_lengths_[axis] = encoder_pos;  // 同步更新leg长度
                } catch (Tango::DevFailed &e) {
                    // 读取失败，使用上次的值
                    WARN_STREAM << "Failed to read encoder channel " << encoder_channel 
                               << " for axis " << axis << ": " << e.errors[0].desc << endl;
                }
            }
        }
    } catch (Tango::DevFailed &e) {
        WARN_STREAM << "Failed to read encoder positions: " << e.errors[0].desc << endl;
        // 读取失败，使用存储的值
        axis_pos_ = current_leg_lengths_;
    } catch (...) {
        WARN_STREAM << "Unknown error reading encoder positions" << endl;
        axis_pos_ = current_leg_lengths_;
    }
}
```

## 工作流程

### 编码器数据流

```
硬件编码器 (AELAN10)
   通道0-5 (192.168.1.199)
        ↓
编码器采集器设备 (sys/encoder/1)
   readEncoder(channel)命令
        ↓
六自由度设备 (sys/six_dof/1)
   update_axis_positions()
        ↓
   axis_pos_[6] 数组
        ↓
   axisPos属性 (Tango)
```

### 调用时机

`update_axis_positions()` 会在以下时候被调用，从而读取编码器：

1. **读取属性时** - `read_axis_pos()`
2. **执行readEncoder命令时** - `readEncoder()`
3. **保存编码器位置时** - `saveEncoderPositions()`
4. **更新位姿时** - `update_pose_from_encoders()`

### 运行模式

#### 真实模式 (sim_mode_ = false)
- 从硬件编码器读取实时位置
- 每次调用都会通过网络访问编码器设备
- 可以检测实际位置和命令位置的偏差

#### 模拟模式 (sim_mode_ = true)
- 使用内部计算的 `current_leg_lengths_` 值
- 不访问硬件
- 用于调试和测试

## 编码器通道映射

根据配置文件 `config/devices_config.json`：

```json
{
  "encoderChannels": ["0", "1", "2", "3", "4", "5"]
}
```

| 轴编号 | 编码器通道 | 采集器 | 物理通道 |
|--------|-----------|--------|---------|
| 0 | 0 | 192.168.1.199 | 通道1 |
| 1 | 1 | 192.168.1.199 | 通道2 |
| 2 | 2 | 192.168.1.199 | 通道3 |
| 3 | 3 | 192.168.1.199 | 通道4 |
| 4 | 4 | 192.168.1.199 | 通道5 |
| 5 | 5 | 192.168.1.199 | 通道6 |

## 使用示例

### Python - 读取编码器位置

```python
import tango

device = tango.DeviceProxy("sys/six_dof/1")

# 方式1: 读取axisPos属性（会自动调用update_axis_positions）
axis_pos = device.read_attribute("axisPos").value
print(f"编码器位置: {axis_pos}")

# 方式2: 调用readEncoder命令
encoder_values = device.command_inout("readEncoder")
print(f"编码器位置: {encoder_values}")

# 两种方式结果相同，都会从硬件读取
```

### Python - 实时监控编码器

```python
import tango
import time

device = tango.DeviceProxy("sys/six_dof/1")

print("实时监控编码器位置 (每0.5秒更新一次)")
print("按Ctrl+C停止")

try:
    while True:
        axis_pos = device.read_attribute("axisPos").value
        print(f"\r轴位置: ", end="")
        for i, pos in enumerate(axis_pos):
            print(f"[{i}]={pos:8.3f} ", end="")
        time.sleep(0.5)
except KeyboardInterrupt:
    print("\n监控停止")
```

### C++ - 读取编码器位置

```cpp
#include <tango.h>
#include <iostream>

int main() {
    Tango::DeviceProxy* device = new Tango::DeviceProxy("sys/six_dof/1");
    
    // 读取axisPos属性
    Tango::DeviceAttribute attr = device->read_attribute("axisPos");
    std::vector<double> axis_pos;
    attr >> axis_pos;
    
    std::cout << "编码器位置:" << std::endl;
    for (int i = 0; i < axis_pos.size(); ++i) {
        std::cout << "  轴" << i << ": " << axis_pos[i] << " mm" << std::endl;
    }
    
    delete device;
    return 0;
}
```

## 性能考虑

### 网络通信开销

每次调用 `update_axis_positions()` 需要：
- 6次网络通信（每个轴一次）
- 每次约1-5ms延迟（取决于网络状况）
- 总共约6-30ms

### 优化建议

1. **避免频繁轮询**：不要在循环中连续读取
2. **使用事件机制**：配置属性的change事件，只在变化时接收通知
3. **批量读取**：如果可能，一次读取所有通道（需要编码器设备支持）

## 错误处理

### 编码器读取失败

如果编码器读取失败（网络断开、设备故障等）：
- 会在日志中记录警告
- 使用上次成功读取的值
- 不会抛出异常，保证程序继续运行

### 典型错误日志

```
WARN: Failed to read encoder channel 0 for axis 0: Connection timeout
WARN: Failed to read encoder positions: Device sys/encoder/1 not available
```

## 测试验证

### 测试脚本

```python
#!/usr/bin/env python3
"""测试编码器真实读取"""
import tango
import time

device = tango.DeviceProxy("sys/six_dof/1")

print("测试1: 连续读取10次，观察数值变化")
for i in range(10):
    pos = device.read_attribute("axisPos").value
    print(f"[{i+1}] {pos}")
    time.sleep(0.2)

print("\n测试2: 手动移动设备，观察编码器响应")
print("请手动移动设备...")
input("按Enter开始监控")

for i in range(30):
    pos = device.read_attribute("axisPos").value
    print(f"[{i+1}] {pos}")
    time.sleep(0.5)
```

### 验证方法

1. **静止状态**：编码器值应该稳定（微小噪声±0.001mm可接受）
2. **手动移动**：手动推动设备，编码器值应该实时变化
3. **运动后**：执行运动命令后，编码器值应该更新为新位置
4. **断开编码器**：断开编码器设备，应该使用上次值并有警告日志

## 相关命令和属性

### 命令

- `readEncoder()` - 返回所有6个轴的编码器位置
- `saveEncoderPositions()` - 保存当前编码器位置到数据库

### 属性

- `axisPos` (READ) - 当前编码器位置数组 [6个double]
- `direPos` (READ) - 命令位置数组 [6个double]

### 比较 axisPos vs direPos

- **axisPos**: 从硬件编码器读取的**实际位置**
- **direPos**: 发送给运动控制器的**命令位置**
- 正常情况下两者应该接近，如果偏差大可能有机械问题

## 故障排查

### 问题：编码器值始终为0或不变化

**可能原因：**
1. 编码器设备未启动 - 检查 `sys/encoder/1` 是否在线
2. 编码器通道配置错误 - 检查 `encoderChannels` 配置
3. 运行在模拟模式 - 检查 `sim_mode_` 是否为true

**解决方法：**
```python
device = tango.DeviceProxy("sys/six_dof/1")

# 检查模拟模式
device.command_inout("simSwitch", 0)  # 0=真实模式

# 检查编码器设备
encoder = tango.DeviceProxy("sys/encoder/1")
print(f"编码器状态: {encoder.state()}")
```

### 问题：读取速度慢

**可能原因：**
- 网络延迟高
- 编码器设备响应慢

**解决方法：**
- 减少读取频率
- 使用事件机制替代轮询
- 检查网络连接质量

## 总结

修改后的代码实现了：
✅ 真正从硬件编码器读取实时位置  
✅ 支持模拟模式和真实模式切换  
✅ 完善的错误处理和降级机制  
✅ 同步更新 axis_pos_ 和 current_leg_lengths_  
✅ 日志记录读取失败情况  

现在 `axis_pos_` 数组中存储的是**真实的硬件反馈值**，而不是计算值！
